/**
 * @file test_interop.c
 * @brief Interoperability test for carquet
 *
 * Reads Parquet files generated by other libraries and verifies
 * they can be parsed correctly.
 *
 * Build:
 *   gcc -I../include -o test_interop test_interop.c ../build/libcarquet.a
 *
 * Usage:
 *   ./test_interop <parquet_file>
 *   ./test_interop --dir <directory>  # Test all .parquet files in dir
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <carquet/carquet.h>

typedef struct {
    int files_tested;
    int files_passed;
    int files_failed;
} test_stats_t;

static void print_column_info(const carquet_schema_t* schema, int32_t idx) {
    const carquet_schema_node_t* node = carquet_schema_get_element(schema, idx);
    if (!node) return;

    const char* name = carquet_schema_node_name(node);
    carquet_physical_type_t ptype = carquet_schema_node_physical_type(node);

    const char* ptype_str = "UNKNOWN";
    switch (ptype) {
        case CARQUET_PHYSICAL_BOOLEAN: ptype_str = "BOOLEAN"; break;
        case CARQUET_PHYSICAL_INT32: ptype_str = "INT32"; break;
        case CARQUET_PHYSICAL_INT64: ptype_str = "INT64"; break;
        case CARQUET_PHYSICAL_INT96: ptype_str = "INT96"; break;
        case CARQUET_PHYSICAL_FLOAT: ptype_str = "FLOAT"; break;
        case CARQUET_PHYSICAL_DOUBLE: ptype_str = "DOUBLE"; break;
        case CARQUET_PHYSICAL_BYTE_ARRAY: ptype_str = "BYTE_ARRAY"; break;
        case CARQUET_PHYSICAL_FIXED_LEN_BYTE_ARRAY: ptype_str = "FIXED_LEN_BYTE_ARRAY"; break;
    }

    printf("    [%d] %s: %s\n", idx, name ? name : "(null)", ptype_str);
}

static int test_file(const char* path, int verbose) {
    carquet_error_t err = CARQUET_ERROR_INIT;

    if (verbose) {
        printf("\n=== Testing: %s ===\n", path);
    }

    /* Open file */
    carquet_reader_t* reader = carquet_reader_open(path, NULL, &err);
    if (!reader) {
        printf("  FAIL: Could not open file: %s\n", err.message);
        return 1;
    }

    /* Get metadata */
    int64_t num_rows = carquet_reader_num_rows(reader);
    int32_t num_cols = carquet_reader_num_columns(reader);
    int32_t num_row_groups = carquet_reader_num_row_groups(reader);

    if (verbose) {
        printf("  Rows: %lld\n", (long long)num_rows);
        printf("  Columns: %d\n", num_cols);
        printf("  Row groups: %d\n", num_row_groups);
    }

    /* Get schema */
    const carquet_schema_t* schema = carquet_reader_schema(reader);
    if (!schema) {
        printf("  FAIL: Could not get schema\n");
        carquet_reader_close(reader);
        return 1;
    }

    if (verbose) {
        printf("  Schema:\n");
        int32_t num_elements = carquet_schema_num_elements(schema);
        for (int32_t i = 0; i < num_elements; i++) {
            print_column_info(schema, i);
        }
    }

    /* Test batch reader API */
    int64_t total_rows_read = 0;
    int read_errors = 0;
    int batch_count = 0;

    carquet_batch_reader_config_t config;
    carquet_batch_reader_config_init(&config);
    config.batch_size = 10000;

    carquet_batch_reader_t* batch_reader =
        carquet_batch_reader_create(reader, &config, &err);
    if (batch_reader) {
        carquet_row_batch_t* batch = NULL;
        carquet_status_t next_status;

        while ((next_status = carquet_batch_reader_next(batch_reader, &batch)) == CARQUET_OK && batch) {
            batch_count++;
            for (int32_t col = 0; col < num_cols; col++) {
                const void* data;
                const uint8_t* nulls;
                int64_t count;
                carquet_status_t status =
                    carquet_row_batch_column(batch, col, &data, &nulls, &count);
                if (status == CARQUET_OK) {
                    total_rows_read += count;
                } else {
                    read_errors++;
                }
            }
            carquet_row_batch_free(batch);
            batch = NULL;
        }

        /* END_OF_DATA is expected when we've read all rows */
        if (next_status != CARQUET_OK && next_status != 63) {  /* 63 = END_OF_DATA */
            if (verbose) {
                printf("  WARN: batch_reader_next failed with status %d\n", next_status);
            }
            read_errors++;
        }

        carquet_batch_reader_free(batch_reader);
    } else {
        if (verbose) {
            printf("  WARN: Could not create batch reader: %s\n", err.message);
        }
        read_errors++;
    }

    carquet_reader_close(reader);

    if (verbose) {
        printf("  Batches read: %d, rows per column: %lld (expected: %lld)\n",
               batch_count, (long long)(total_rows_read / (num_cols > 0 ? num_cols : 1)),
               (long long)num_rows);
    }

    if (read_errors > 0 || (num_rows > 0 && total_rows_read == 0)) {
        printf("  PARTIAL: %d read errors, %d batches, file parsed\n", read_errors, batch_count);
        return 0;  /* Still count as pass if we could parse metadata */
    }

    if (verbose) {
        printf("  PASS: Read data successfully\n");
    }

    return 0;
}

static int test_directory(const char* dir_path, test_stats_t* stats, int verbose) {
    DIR* dir = opendir(dir_path);
    if (!dir) {
        perror("opendir");
        return 1;
    }

    struct dirent* entry;
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_name[0] == '.') continue;

        char path[4096];
        snprintf(path, sizeof(path), "%s/%s", dir_path, entry->d_name);

        struct stat st;
        if (stat(path, &st) != 0) continue;

        if (S_ISDIR(st.st_mode)) {
            /* Recurse into subdirectory */
            test_directory(path, stats, verbose);
        } else if (S_ISREG(st.st_mode)) {
            /* Check if it's a .parquet file */
            const char* ext = strrchr(entry->d_name, '.');
            if (ext && strcmp(ext, ".parquet") == 0) {
                stats->files_tested++;
                if (test_file(path, verbose) == 0) {
                    stats->files_passed++;
                    if (!verbose) printf(".");
                } else {
                    stats->files_failed++;
                    if (!verbose) printf("F");
                }
                fflush(stdout);
            }
        }
    }

    closedir(dir);
    return 0;
}

int main(int argc, char** argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <parquet_file>\n", argv[0]);
        fprintf(stderr, "       %s --dir <directory> [-v]\n", argv[0]);
        return 1;
    }

    (void)carquet_init();

    int verbose = 0;
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
            verbose = 1;
        }
    }

    if (strcmp(argv[1], "--dir") == 0) {
        if (argc < 3) {
            fprintf(stderr, "Error: --dir requires a directory path\n");
            return 1;
        }

        test_stats_t stats = {0, 0, 0};

        printf("Testing all .parquet files in: %s\n", argv[2]);
        if (!verbose) printf("Progress: ");

        test_directory(argv[2], &stats, verbose);

        printf("\n\n=== Summary ===\n");
        printf("Files tested: %d\n", stats.files_tested);
        printf("Passed: %d\n", stats.files_passed);
        printf("Failed: %d\n", stats.files_failed);

        return stats.files_failed > 0 ? 1 : 0;
    } else {
        return test_file(argv[1], 1);
    }
}
